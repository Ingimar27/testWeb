<html lang='en'>
<head>
    <meta charset='UTF-8'>
    <title>Handlandmark - rotation</title>
    <style>    
html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    font-family: 'Roboto', sans-serif;
    background: #1e1e2f;
    color: #f0f0f5;
}

body {
    display: flex;
    justify-content: center;
    align-items: flex-start;
    gap: 30px;
    flex-wrap: wrap;
    padding: 20px;
}

.video-wrapper {
    position: relative;
    width: 480px;
    max-width: 90%;
    border-radius: 15px;
    overflow: hidden;
    box-shadow: 0 8px 20px rgba(0,0,0,0.5);
    background: #2e2e3f;
}

video, #output_canvas {
    width: 100%;
    height: auto;
    display: block;
    transform: rotateY(180deg);
    border-radius: 15px;
}

#output_canvas {
    position: absolute;
    top: 0;
    left: 0;
    pointer-events: none;
}

#scene-container {
    flex: 1;
    min-width: 480px;
    max-width: 1000px;
    min-height: 800px;
    background: #2e2e3f;
    border-radius: 15px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.6);
    padding: 15px;
    display: flex;
    align-items: center;
    justify-content: center;
}

button#webcamButton {
    display: block;
    margin: 10px auto;
    background-color: #ff6f61;
    color: #fff;
    border: none;
    border-radius: 10px;
    padding: 12px 25px;
    font-size: 16px;
    cursor: pointer;
    transition: background 0.3s ease, transform 0.2s ease;
}

button#webcamButton:hover {
    background-color: #ff4b3a;
    transform: scale(1.05);
}

#lockStatus {
    font-size: 18px;
    font-weight: bold;
    margin: 10px 0;
    text-align: center;
    color: #f0f0f5;
}

.iconcon {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    margin: 5px 0;
    font-weight: 500;
    color: #f0f0f5;
}

.palmicon {
    height: 40px;
    width: auto;
}

canvas {
    border-radius: 15px;
}
.overlay-image {
    display: block;
    width: 100%;
    max-width: 480px;
    height: auto;
    margin-top: 10px;
    border-radius: 10px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.5);
}
    </style>
</head>
<body>
    <div>
        <button id='webcamButton'>ENABLE WEBCAM</button>
        <p id="lockStatus" style="font-size: 20px; font-weight: bold; color: red;">Status: Unknown</p>
        <div class="video-wrapper">
            <!-- âœ… playsinline + muted so iOS/Android allow camera -->
            <video id='webcam' autoplay playsinline muted></video>
            <canvas id='output_canvas' width='480' height='480'></canvas>
            <img src="f973b456-c007-41c5-97fb-169642dd787e.png" alt="Your Image" class="overlay-image">
        </div>
    </div>

    <div id="scene-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@v0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@v0.158.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from "three";
        import { HandLandmarker, FilesetResolver, DrawingUtils } 
            from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3';

        const container = document.querySelector("#scene-container");
        const scene = new THREE.Scene();
        scene.background = new THREE.Color("white");

        const fov = 35;
        const aspect = container.clientWidth / container.clientHeight;
        const near = 0.1;
        const far = 100;
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.set(0, 10, 30);

        const cubematerial = new THREE.MeshStandardMaterial({ color: new THREE.Color(0xff0000) });
        const cubegeometry = new THREE.BoxGeometry(4, 4, 4);
        const cube = new THREE.Mesh(cubegeometry, cubematerial);
        scene.add(cube);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(10, 10, 10);
        directionalLight.target = cube;
        scene.add(directionalLight);

        camera.lookAt(cube.position);
        scene.add(new THREE.AmbientLight(0x404040));

        const renderer = new THREE.WebGLRenderer({ preserveDrawingBuffer: true, precision: "lowp", antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.append(renderer.domElement);

        let scaleValue = 1;

        function animate() {
            cube.scale.set(scaleValue, scaleValue, scaleValue);
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        animate();

        window.addEventListener("resize", () => location.reload());

        let results = undefined;
        let handLandmarker;
        let runningMode = 'IMAGE';
        let webcamRunning = false;
        const video = document.getElementById('webcam');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        let enableWebcamButton = document.getElementById('webcamButton');
        let lastVideoTime = -1;

        const createHandLandmarker = async () => {
            const vision = await FilesetResolver.forVisionTasks('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm');
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/latest/hand_landmarker.task',
                    delegate: 'GPU'
                },
                numHands: 2,
                runningMode: runningMode,
            });
        };
        createHandLandmarker();

        function enableCam() {
            if (!handLandmarker) {
                console.log("Wait for handLandmarker to load before clicking!");
                return;
            }
            webcamRunning = !webcamRunning;
            const constraints = { video: true };
            navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {
                video.srcObject = stream;
                video.addEventListener('loadeddata', predictWebcam);
            });
        }
        enableWebcamButton.addEventListener('click', enableCam);

        async function predictWebcam() {
            if (runningMode === "IMAGE") {
                runningMode = "VIDEO";
                await handLandmarker.setOptions({ runningMode: "VIDEO" });
            }

            let startTimeMs = performance.now();
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                results = handLandmarker.detectForVideo(video, startTimeMs);
            }

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            const drawingUtils = new DrawingUtils(canvasCtx);

            if (results.landmarks.length > 0) {
                // (Your landmark logic here)
                drawingUtils.drawConnectors(results.landmarks[0], HandLandmarker.HAND_CONNECTIONS, { color: "#00FF00", lineWidth: 5 });
                drawingUtils.drawLandmarks(results.landmarks[0], { color: "#FF0000", lineWidth: 2 });
            }

            canvasCtx.restore();
            if (webcamRunning === true) {
                window.requestAnimationFrame(predictWebcam);
            }
        }
    </script>
</body>
</html>
